import numpy as np
import torch
torch.set_num_threads(1)

def getOptions(opts, vars):
    '''
    SSI function called to get the options of the component and initialize the variables.

    Args:
        opts (dictionary<string,any>): options of the component
        vars (dictionary<string,any>): internal variables of the component
    '''
    
    opts['vad_tresh'] = 0.3
    opts['vad_calibration'] = False

    vars['event_vad'] = False
    vars['loaded'] = False
    vars['dummy_event'] = False

    try:
        load_model(opts, vars)
        vars['loaded'] = True
    except Exception as ex:
        print(ex)

def getEventAddress(opts, vars):
    '''
    SSI function called to get the address of the events that the component can generate.

    Args:
        opts (dictionary<string,any>): options of the component
        vars (dictionary<string,any>): internal variables of the component
    '''

    return 'vad,vad-tresh@audio'

def getSampleTypeOut(type, types, opts, vars): 
    '''
    SSI function called to get the type of the samples generated by the component.

    Args:
        type (ssipystreamtype): type of the samples generated by the component
        types (ssipystreamtype): enumeration of types of the samples
        opts (dictionary<string,any>): options of the component
        vars (dictionary<string,any>): internal variables of the component
    '''

    if type != types.FLOAT:  
        print('types other than float are not supported') 
        return types.UNDEF

    return type

def transform(info, sin, sout, sxtras, board, opts, vars):
    '''
    SSI function called to transform the input samples into the output samples.
    Analyze the audio and return the confidence of the presence of speech based on a treshold as a stream.
    Moreover send an event when the VAD state changes, signaling the beginning and the end of the speech.
    Finally, if the calibration option is enabled, an event with the initial treshold is sent.

    Args:
        info (ssipyinfo): information about the input samples
        sin (ssipystream): input samples
        sout (ssipystream): output samples
        sextras (tuple<ssipystream>): extra streams of samples
        board (ssipyeventboard): event board to send events
        opts (dictionary<string,any>): options of the component
        vars (dictionary<string,any>): internal variables of the component
    '''

    if vars['loaded']:
        if opts['vad_calibration'] and not vars['dummy_event']:
            vars['initial_vad_tresh'] = opts['vad_tresh']
            vars['old_vad_tresh'] = opts['vad_tresh']
            board.update(0, 0, 'vad-tresh@audio', opts['vad_tresh'])
            vars['dummy_event'] = True

        time_ms = round(1000 * info.time)
        audio_float32 = np.array(sin, dtype=np.float32).squeeze()

        new_confidence = vars['model'](torch.from_numpy(audio_float32), 16000).item()
        
        for n in range(sout.num):
            sout[n] = 0
        if type(new_confidence) == float:
            sout[0] = new_confidence
        
        if new_confidence > opts['vad_tresh'] and not vars['event_vad']:
            vars['event_vad'] = True
            board.update(time_ms, 0, 'vad@audio', state=board.CONTINUED)
        elif new_confidence < opts['vad_tresh'] and vars['event_vad']:
            vars['event_vad'] = False
            board.update(time_ms, 0, 'vad@audio', state=board.COMPLETED)

def transform_flush(sin, sout, sxtras, board, opts, vars):
    '''
    SSI function called when the processing was stopped.
    If the calibration option is enabled, the treshold is updated in the pipeline configuration file.

    Args:
        sin (ssipystream): input samples
        sout (ssipystream): output samples
        sextras (tuple<ssipystream>): extra streams of samples
        board (ssipyeventboard): event board to send events
        opts (dictionary<string,any>): options of the component
        vars (dictionary<string,any>): internal variables of the component
    '''

    if vars['loaded'] and opts['vad_calibration'] and vars['initial_vad_tresh'] != opts['vad_tresh']:
        with open('../pipes/vad_filter.pipeline-config', 'r') as file:
            old_configs = file.readlines()

        with open('../pipes/vad_filter.pipeline-config', 'w') as file:
            for i, line in enumerate(old_configs):
                if 'vad:tresh' == line.split(" = ")[0]:
                    old_configs[i] = f'vad:tresh = {opts["vad_tresh"]}\n'
                    print('Edited treshold',vars['initial_vad_tresh'],'to',opts['vad_tresh'])
                    break

            file.writelines(old_configs)

def update(event, board, opts, vars):
    '''
    SSI function called when an event is received.
    If the calibration option is enabled, the treshold is updated.

    Args:
        event (ssipyevent): event received
        board (ssipyeventboard): event board to send events
        opts (dictionary<string,any>): options of the component
        vars (dictionary<string,any>): internal variables of the component
    '''

    if vars['loaded'] and opts['vad_calibration'] and event.address == 'calibration@vad':
        try:
            tmp = float(event.data)
            if tmp < 0 or tmp > 1:
                raise 'Invalid value for treshold. Please enter a value between 0 and 1.'
            elif tmp != vars['old_vad_tresh']:
                opts['vad_tresh'] = tmp
                board.update(0, 0, 'vad-tresh@audio', opts['vad_tresh'])
                vars['old_vad_tresh'] = opts['vad_tresh']
        except:
            print('Invalid value for treshold. Please enter a value between 0 and 1.')


def load_model(opts, vars):
    '''
    Load the VAD model from the Silero VAD repository.

    Args:
        opts (dictionary<string,any>): options of the component
        vars (dictionary<string,any>): internal variables of the component
    '''

    model, utils = torch.hub.load(repo_or_dir='snakers4/silero-vad',
        model='silero_vad',
        force_reload=True)
    (get_speech_timestamps,
        save_audio,
        read_audio,
        VADIterator,
        collect_chunks) = utils

    vars['model'] = model
    vars['utils'] = utils
    vars['get_speech_timestamps'] = get_speech_timestamps
    vars['save_audio'] = save_audio
    vars['read_audio'] = read_audio
    vars['VADIterator'] = VADIterator
    vars['collect_chunks'] = collect_chunks

def int2float(sound):
    '''
    Convert the input sound from int16 to float32.

    Args:
        sound (numpy.ndarray): input sound in int16

    Returns:
        numpy.ndarray: sound in float32
    '''

    abs_max = np.abs(sound).max()
    sound = sound.astype('float32')
    if abs_max > 0:
        sound *= 1/32768
    sound = sound.squeeze()  # depends on the use case
    return sound